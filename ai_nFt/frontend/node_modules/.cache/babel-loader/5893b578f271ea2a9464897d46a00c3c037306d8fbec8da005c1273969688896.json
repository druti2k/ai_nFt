{"ast":null,"code":"import { PublicKey } from '@solana/web3.js';\nimport { addCodecSizePrefix, fixCodecSize, getArrayCodec, getBytesCodec, getUtf8Codec, getU32Codec, getStructCodec, getTupleCodec } from '@solana/codecs';\nexport const TOKEN_METADATA_DISCRIMINATOR = Buffer.from([112, 132, 90, 90, 11, 88, 157, 87]);\nfunction getStringCodec() {\n  return addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n}\nconst tokenMetadataCodec = getStructCodec([['updateAuthority', fixCodecSize(getBytesCodec(), 32)], ['mint', fixCodecSize(getBytesCodec(), 32)], ['name', getStringCodec()], ['symbol', getStringCodec()], ['uri', getStringCodec()], ['additionalMetadata', getArrayCodec(getTupleCodec([getStringCodec(), getStringCodec()]))]]);\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer) {\n  for (let i = 0; i < buffer.length; i++) {\n    if (buffer[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n// Pack TokenMetadata into byte slab\nexport function pack(meta) {\n  // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n  const updateAuthority = meta.updateAuthority ?? PublicKey.default;\n  return tokenMetadataCodec.encode({\n    ...meta,\n    updateAuthority: updateAuthority.toBuffer(),\n    mint: meta.mint.toBuffer()\n  });\n}\n// unpack byte slab into TokenMetadata\nexport function unpack(buffer) {\n  const data = tokenMetadataCodec.decode(buffer);\n  return isNonePubkey(data.updateAuthority) ? {\n    mint: new PublicKey(data.mint),\n    name: data.name,\n    symbol: data.symbol,\n    uri: data.uri,\n    additionalMetadata: data.additionalMetadata\n  } : {\n    updateAuthority: new PublicKey(data.updateAuthority),\n    mint: new PublicKey(data.mint),\n    name: data.name,\n    symbol: data.symbol,\n    uri: data.uri,\n    additionalMetadata: data.additionalMetadata\n  };\n}\n//# sourceMappingURL=state.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}