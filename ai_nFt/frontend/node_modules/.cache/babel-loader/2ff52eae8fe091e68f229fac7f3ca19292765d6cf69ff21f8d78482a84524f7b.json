{"ast":null,"code":"import { TokenTransferHookAccountDataNotFound, TokenTransferHookInvalidSeed } from '../../errors.js';\nconst DISCRIMINATOR_SPAN = 1;\nconst LITERAL_LENGTH_SPAN = 1;\nconst INSTRUCTION_ARG_OFFSET_SPAN = 1;\nconst INSTRUCTION_ARG_LENGTH_SPAN = 1;\nconst ACCOUNT_KEY_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_OFFSET_SPAN = 1;\nconst ACCOUNT_DATA_LENGTH_SPAN = 1;\nfunction unpackSeedLiteral(seeds) {\n  if (seeds.length < 1) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const [length, ...rest] = seeds;\n  if (rest.length < length) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: Buffer.from(rest.slice(0, length)),\n    packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length\n  };\n}\nfunction unpackSeedInstructionArg(seeds, instructionData) {\n  if (seeds.length < 2) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const [index, length] = seeds;\n  if (instructionData.length < length + index) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: instructionData.subarray(index, index + length),\n    packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN\n  };\n}\nfunction unpackSeedAccountKey(seeds, previousMetas) {\n  if (seeds.length < 1) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const [index] = seeds;\n  if (previousMetas.length <= index) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: previousMetas[index].pubkey.toBuffer(),\n    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN\n  };\n}\nasync function unpackSeedAccountData(seeds, previousMetas, connection) {\n  if (seeds.length < 3) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const [accountIndex, dataIndex, length] = seeds;\n  if (previousMetas.length <= accountIndex) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n  if (accountInfo == null) {\n    throw new TokenTransferHookAccountDataNotFound();\n  }\n  if (accountInfo.data.length < dataIndex + length) {\n    throw new TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: accountInfo.data.subarray(dataIndex, dataIndex + length),\n    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN\n  };\n}\nasync function unpackFirstSeed(seeds, previousMetas, instructionData, connection) {\n  const [discriminator, ...rest] = seeds;\n  const remaining = new Uint8Array(rest);\n  switch (discriminator) {\n    case 0:\n      return null;\n    case 1:\n      return unpackSeedLiteral(remaining);\n    case 2:\n      return unpackSeedInstructionArg(remaining, instructionData);\n    case 3:\n      return unpackSeedAccountKey(remaining, previousMetas);\n    case 4:\n      return unpackSeedAccountData(remaining, previousMetas, connection);\n    default:\n      throw new TokenTransferHookInvalidSeed();\n  }\n}\nexport async function unpackSeeds(seeds, previousMetas, instructionData, connection) {\n  const unpackedSeeds = [];\n  let i = 0;\n  while (i < 32) {\n    const seed = await unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);\n    if (seed == null) {\n      break;\n    }\n    unpackedSeeds.push(seed.data);\n    i += seed.packedLength;\n  }\n  return unpackedSeeds;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}