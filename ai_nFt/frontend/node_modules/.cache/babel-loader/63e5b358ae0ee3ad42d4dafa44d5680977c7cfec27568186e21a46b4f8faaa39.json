{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unpackAccount = exports.getMinimumBalanceForRentExemptAccountWithExtensions = exports.getMinimumBalanceForRentExemptAccount = exports.getMultipleAccounts = exports.getAccount = exports.ACCOUNT_SIZE = exports.AccountLayout = exports.AccountState = void 0;\nconst buffer_layout_1 = require(\"@solana/buffer-layout\");\nconst buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\nconst constants_js_1 = require(\"../constants.js\");\nconst errors_js_1 = require(\"../errors.js\");\nconst accountType_js_1 = require(\"../extensions/accountType.js\");\nconst extensionType_js_1 = require(\"../extensions/extensionType.js\");\nconst multisig_js_1 = require(\"./multisig.js\");\n/** Token account state as stored by the program */\nvar AccountState;\n(function (AccountState) {\n  AccountState[AccountState[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  AccountState[AccountState[\"Initialized\"] = 1] = \"Initialized\";\n  AccountState[AccountState[\"Frozen\"] = 2] = \"Frozen\";\n})(AccountState || (exports.AccountState = AccountState = {}));\n/** Buffer layout for de/serializing a token account */\nexports.AccountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)('mint'), (0, buffer_layout_utils_1.publicKey)('owner'), (0, buffer_layout_utils_1.u64)('amount'), (0, buffer_layout_1.u32)('delegateOption'), (0, buffer_layout_utils_1.publicKey)('delegate'), (0, buffer_layout_1.u8)('state'), (0, buffer_layout_1.u32)('isNativeOption'), (0, buffer_layout_utils_1.u64)('isNative'), (0, buffer_layout_utils_1.u64)('delegatedAmount'), (0, buffer_layout_1.u32)('closeAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('closeAuthority')]);\n/** Byte length of a token account */\nexports.ACCOUNT_SIZE = exports.AccountLayout.span;\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nfunction getAccount(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const info = yield connection.getAccountInfo(address, commitment);\n    return unpackAccount(address, info, programId);\n  });\n}\nexports.getAccount = getAccount;\n/**\n * Retrieve information about multiple token accounts in a single RPC call\n *\n * @param connection Connection to use\n * @param addresses  Token accounts\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nfunction getMultipleAccounts(connection, addresses, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const infos = yield connection.getMultipleAccountsInfo(addresses, commitment);\n    return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\n  });\n}\nexports.getMultipleAccounts = getMultipleAccounts;\n/** Get the minimum lamport balance for a base token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nfunction getMinimumBalanceForRentExemptAccount(connection, commitment) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return yield getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n  });\n}\nexports.getMinimumBalanceForRentExemptAccount = getMinimumBalanceForRentExemptAccount;\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nfunction getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const accountLen = (0, extensionType_js_1.getAccountLen)(extensions);\n    return yield connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n  });\n}\nexports.getMinimumBalanceForRentExemptAccountWithExtensions = getMinimumBalanceForRentExemptAccountWithExtensions;\n/**\n * Unpack a token account\n *\n * @param address   Token account\n * @param info      Token account data\n * @param programId SPL Token program account\n *\n * @return Unpacked token account\n */\nfunction unpackAccount(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {\n  if (!info) throw new errors_js_1.TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new errors_js_1.TokenInvalidAccountOwnerError();\n  if (info.data.length < exports.ACCOUNT_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n  const rawAccount = exports.AccountLayout.decode(info.data.slice(0, exports.ACCOUNT_SIZE));\n  let tlvData = Buffer.alloc(0);\n  if (info.data.length > exports.ACCOUNT_SIZE) {\n    if (info.data.length === multisig_js_1.MULTISIG_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n    if (info.data[exports.ACCOUNT_SIZE] != accountType_js_1.AccountType.Account) throw new errors_js_1.TokenInvalidAccountError();\n    tlvData = info.data.slice(exports.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);\n  }\n  return {\n    address,\n    mint: rawAccount.mint,\n    owner: rawAccount.owner,\n    amount: rawAccount.amount,\n    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n    delegatedAmount: rawAccount.delegatedAmount,\n    isInitialized: rawAccount.state !== AccountState.Uninitialized,\n    isFrozen: rawAccount.state === AccountState.Frozen,\n    isNative: !!rawAccount.isNativeOption,\n    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n    tlvData\n  };\n}\nexports.unpackAccount = unpackAccount;\n//# sourceMappingURL=account.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}