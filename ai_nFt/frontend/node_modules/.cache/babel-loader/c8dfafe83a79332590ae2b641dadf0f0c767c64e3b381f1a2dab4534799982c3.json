{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function () {\n  var ownKeys = function (o) {\n    ownKeys = Object.getOwnPropertyNames || function (o) {\n      var ar = [];\n      for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n      return ar;\n    };\n    return ownKeys(o);\n  };\n  return function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    __setModuleDefault(result, mod);\n    return result;\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AiNftClient = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst borsh = __importStar(require(\"borsh\"));\n// The address of your deployed program\nconst PROGRAM_ID = new web3_js_1.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n// Define instruction data layout using borsh\nclass InitializeInstruction {\n  constructor(props) {\n    Object.defineProperty(this, \"instruction\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    }); // 0 = Initialize\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"symbol\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"uri\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = props.name;\n    this.symbol = props.symbol;\n    this.uri = props.uri;\n  }\n}\nObject.defineProperty(InitializeInstruction, \"schema\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: new Map([[InitializeInstruction, {\n    kind: 'struct',\n    fields: [['instruction', 'u8'], ['name', 'string'], ['symbol', 'string'], ['uri', 'string']]\n  }]])\n});\nclass MintInstruction {\n  constructor(props) {\n    Object.defineProperty(this, \"instruction\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    }); // 1 = Mint\n    Object.defineProperty(this, \"tokenId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"imageUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"metadata\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.tokenId = props.tokenId;\n    this.imageUrl = props.imageUrl;\n    this.metadata = props.metadata;\n  }\n}\nObject.defineProperty(MintInstruction, \"schema\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: new Map([[MintInstruction, {\n    kind: 'struct',\n    fields: [['instruction', 'u8'], ['tokenId', 'string'], ['imageUrl', 'string'], ['metadata', 'string']]\n  }]])\n});\nclass TransferInstruction {\n  constructor(props) {\n    Object.defineProperty(this, \"instruction\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 2\n    }); // 2 = Transfer\n    Object.defineProperty(this, \"amount\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.amount = props.amount;\n  }\n}\nObject.defineProperty(TransferInstruction, \"schema\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: new Map([[TransferInstruction, {\n    kind: 'struct',\n    fields: [['instruction', 'u8'], ['amount', 'u64']]\n  }]])\n});\nclass AiNftClient {\n  constructor(connection, payer) {\n    Object.defineProperty(this, \"connection\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"payer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.connection = connection;\n    this.payer = payer;\n  }\n  async initialize(name, symbol, uri) {\n    const mintKeypair = web3_js_1.Keypair.generate();\n    const lamports = await (0, spl_token_1.getMinimumBalanceForRentExemptMint)(this.connection);\n    const [metadataAddress] = await web3_js_1.PublicKey.findProgramAddress([Buffer.from('metadata'), mintKeypair.publicKey.toBuffer()], PROGRAM_ID);\n    const tokenAddress = await (0, spl_token_1.getAssociatedTokenAddress)(mintKeypair.publicKey, this.payer.publicKey);\n    // Create instruction data\n    const instructionData = new InitializeInstruction({\n      name,\n      symbol,\n      uri\n    });\n    const serializedData = borsh.serialize(InitializeInstruction.schema, instructionData);\n    // Create a transaction\n    const transaction = new web3_js_1.Transaction().add(\n    // Create the mint account\n    web3_js_1.SystemProgram.createAccount({\n      fromPubkey: this.payer.publicKey,\n      newAccountPubkey: mintKeypair.publicKey,\n      space: spl_token_1.MINT_SIZE,\n      lamports,\n      programId: spl_token_1.TOKEN_PROGRAM_ID\n    }),\n    // Initialize the mint\n    (0, spl_token_1.createInitializeMintInstruction)(mintKeypair.publicKey, 0,\n    // Decimals\n    this.payer.publicKey, this.payer.publicKey),\n    // Create the associated token account\n    (0, spl_token_1.createAssociatedTokenAccountInstruction)(this.payer.publicKey, tokenAddress, this.payer.publicKey, mintKeypair.publicKey),\n    // Initialize the NFT with our program\n    {\n      keys: [{\n        pubkey: this.payer.publicKey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: mintKeypair.publicKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenAddress,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: web3_js_1.SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: spl_token_1.TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: metadataAddress,\n        isSigner: false,\n        isWritable: true\n      },\n      // Add your Metaplex Token Metadata program ID here\n      {\n        pubkey: new web3_js_1.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'),\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: PROGRAM_ID,\n      data: Buffer.from(serializedData)\n    });\n    // Sign and send the transaction\n    const signature = await (0, web3_js_1.sendAndConfirmTransaction)(this.connection, transaction, [this.payer, mintKeypair]);\n    return signature;\n  }\n  async mint(mintPubkey, tokenAddress, tokenId, imageUrl, metadata) {\n    const [metadataAddress] = await web3_js_1.PublicKey.findProgramAddress([Buffer.from('metadata'), mintPubkey.toBuffer()], PROGRAM_ID);\n    // Create instruction data\n    const instructionData = new MintInstruction({\n      tokenId,\n      imageUrl,\n      metadata\n    });\n    const serializedData = borsh.serialize(MintInstruction.schema, instructionData);\n    // Create transaction\n    const transaction = new web3_js_1.Transaction().add({\n      keys: [{\n        pubkey: this.payer.publicKey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: mintPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenAddress,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: web3_js_1.SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: spl_token_1.TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: metadataAddress,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: new web3_js_1.PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'),\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: PROGRAM_ID,\n      data: Buffer.from(serializedData)\n    });\n    // Sign and send the transaction\n    const signature = await (0, web3_js_1.sendAndConfirmTransaction)(this.connection, transaction, [this.payer]);\n    return signature;\n  }\n  async transfer(source, destination, amount) {\n    // Create instruction data\n    const instructionData = new TransferInstruction({\n      amount\n    });\n    const serializedData = borsh.serialize(TransferInstruction.schema, instructionData);\n    // Create transaction\n    const transaction = new web3_js_1.Transaction().add({\n      keys: [{\n        pubkey: this.payer.publicKey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: web3_js_1.SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: spl_token_1.TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: PROGRAM_ID,\n      data: Buffer.from(serializedData)\n    });\n    // Sign and send the transaction\n    const signature = await (0, web3_js_1.sendAndConfirmTransaction)(this.connection, transaction, [this.payer]);\n    return signature;\n  }\n}\nexports.AiNftClient = AiNftClient;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}