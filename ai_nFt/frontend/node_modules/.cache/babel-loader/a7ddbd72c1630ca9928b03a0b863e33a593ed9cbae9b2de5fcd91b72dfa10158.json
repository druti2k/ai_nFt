{"ast":null,"code":"import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\nexport var TransferHookInstruction;\n(function (TransferHookInstruction) {\n  TransferHookInstruction[TransferHookInstruction[\"Initialize\"] = 0] = \"Initialize\";\n  TransferHookInstruction[TransferHookInstruction[\"Update\"] = 1] = \"Update\";\n})(TransferHookInstruction || (TransferHookInstruction = {}));\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct([u8('instruction'), u8('transferHookInstruction'), publicKey('authority'), publicKey('transferHookProgramId')]);\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n  initializeTransferHookInstructionData.encode({\n    instruction: TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Initialize,\n    authority,\n    transferHookProgramId\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct([u8('instruction'), u8('transferHookInstruction'), publicKey('transferHookProgramId')]);\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }], authority, multiSigners);\n  const data = Buffer.alloc(updateTransferHookInstructionData.span);\n  updateTransferHookInstructionData.encode({\n    instruction: TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Update,\n    transferHookProgramId\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\nfunction deEscalateAccountMeta(accountMeta, accountMetas) {\n  const maybeHighestPrivileges = accountMetas.filter(x => x.pubkey === accountMeta.pubkey).reduce((acc, x) => {\n    if (!acc) return {\n      isSigner: x.isSigner,\n      isWritable: x.isWritable\n    };\n    return {\n      isSigner: acc.isSigner || x.isSigner,\n      isWritable: acc.isWritable || x.isWritable\n    };\n  }, undefined);\n  if (maybeHighestPrivileges) {\n    const {\n      isSigner,\n      isWritable\n    } = maybeHighestPrivileges;\n    if (!isSigner && isSigner !== accountMeta.isSigner) {\n      accountMeta.isSigner = false;\n    }\n    if (!isWritable && isWritable !== accountMeta.isWritable) {\n      accountMeta.isWritable = false;\n    }\n  }\n  return accountMeta;\n}\n/**\n * Add extra accounts needed for transfer hook to an instruction\n *\n * @param connection      Connection to use\n * @param instruction     The transferChecked instruction to add accounts to\n * @param commitment      Commitment to use\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function addExtraAccountsToInstruction(connection, instruction, mint, commitment, programId = TOKEN_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const mintInfo = await getMint(connection, mint, commitment, programId);\n  const transferHook = getTransferHook(mintInfo);\n  if (transferHook == null) {\n    return instruction;\n  }\n  const extraAccountsAccount = getExtraAccountMetaAddress(mint, transferHook.programId);\n  const extraAccountsInfo = await connection.getAccountInfo(extraAccountsAccount, commitment);\n  if (extraAccountsInfo == null) {\n    return instruction;\n  }\n  const extraAccountMetas = getExtraAccountMetas(extraAccountsInfo);\n  const accountMetas = instruction.keys;\n  for (const extraAccountMeta of extraAccountMetas) {\n    const accountMetaUnchecked = await resolveExtraAccountMeta(connection, extraAccountMeta, accountMetas, instruction.data, transferHook.programId);\n    const accountMeta = deEscalateAccountMeta(accountMetaUnchecked, accountMetas);\n    accountMetas.push(accountMeta);\n  }\n  accountMetas.push({\n    pubkey: transferHook.programId,\n    isSigner: false,\n    isWritable: false\n  });\n  accountMetas.push({\n    pubkey: extraAccountsAccount,\n    isSigner: false,\n    isWritable: false\n  });\n  return new TransactionInstruction({\n    keys: accountMetas,\n    programId,\n    data: instruction.data\n  });\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {\n  const rawInstruction = createTransferCheckedInstruction(source, mint, destination, authority, amount, decimals, multiSigners, programId);\n  const hydratedInstruction = await addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);\n  return hydratedInstruction;\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {\n  const rawInstruction = createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners, programId);\n  const hydratedInstruction = await addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);\n  return hydratedInstruction;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}