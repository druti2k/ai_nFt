{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tokenMetadataUpdateAuthority = exports.tokenMetadataRemoveKey = exports.tokenMetadataUpdateFieldWithRentTransfer = exports.tokenMetadataUpdateField = exports.tokenMetadataInitializeWithRentTransfer = exports.tokenMetadataInitialize = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst spl_token_metadata_1 = require(\"@solana/spl-token-metadata\");\nconst constants_js_1 = require(\"../../constants.js\");\nconst internal_js_1 = require(\"../../actions/internal.js\");\nconst extensionType_js_1 = require(\"../extensionType.js\");\nconst state_js_1 = require(\"./state.js\");\nconst errors_js_1 = require(\"../../errors.js\");\nconst index_js_1 = require(\"../../state/index.js\");\nfunction getAdditionalRentForNewMetadata(connection, address, tokenMetadata, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const info = yield connection.getAccountInfo(address);\n    if (!info) {\n      throw new errors_js_1.TokenAccountNotFoundError();\n    }\n    const extensionLen = (0, spl_token_metadata_1.pack)(tokenMetadata).length;\n    const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);\n    if (newAccountLen <= info.data.length) {\n      return 0;\n    }\n    const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);\n    return newRentExemptMinimum - info.lamports;\n  });\n}\nfunction getAdditionalRentForUpdatedMetadata(connection, address, field, value, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const info = yield connection.getAccountInfo(address);\n    if (!info) {\n      throw new errors_js_1.TokenAccountNotFoundError();\n    }\n    const mint = (0, index_js_1.unpackMint)(address, info, programId);\n    const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mint.tlvData);\n    if (extensionData === null) {\n      throw new Error('TokenMetadata extension not initialized');\n    }\n    const updatedTokenMetadata = (0, state_js_1.updateTokenMetadata)((0, spl_token_metadata_1.unpack)(extensionData), field, value);\n    const extensionLen = (0, spl_token_metadata_1.pack)(updatedTokenMetadata).length;\n    const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);\n    if (newAccountLen <= info.data.length) {\n      return 0;\n    }\n    const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);\n    return newRentExemptMinimum - info.lamports;\n  });\n}\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nfunction tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);\n    const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createInitializeInstruction)({\n      programId,\n      metadata: mint,\n      updateAuthority,\n      mint,\n      mintAuthority: mintAuthorityPublicKey,\n      name,\n      symbol,\n      uri\n    }));\n    return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);\n  });\n}\nexports.tokenMetadataInitialize = tokenMetadataInitialize;\n/**\n * Initializes a TLV entry with the basic token-metadata fields,\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nfunction tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);\n    const transaction = new web3_js_1.Transaction();\n    const lamports = yield getAdditionalRentForNewMetadata(connection, mint, {\n      updateAuthority,\n      mint,\n      name,\n      symbol,\n      uri,\n      additionalMetadata: []\n    }, programId);\n    if (lamports > 0) {\n      transaction.add(web3_js_1.SystemProgram.transfer({\n        fromPubkey: payer.publicKey,\n        toPubkey: mint,\n        lamports: lamports\n      }));\n    }\n    transaction.add((0, spl_token_metadata_1.createInitializeInstruction)({\n      programId,\n      metadata: mint,\n      updateAuthority,\n      mint,\n      mintAuthority: mintAuthorityPublicKey,\n      name,\n      symbol,\n      uri\n    }));\n    return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);\n  });\n}\nexports.tokenMetadataInitializeWithRentTransfer = tokenMetadataInitializeWithRentTransfer;\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nfunction tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);\n    const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateFieldInstruction)({\n      programId,\n      metadata: mint,\n      updateAuthority: updateAuthorityPublicKey,\n      field,\n      value\n    }));\n    return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);\n  });\n}\nexports.tokenMetadataUpdateField = tokenMetadataUpdateField;\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nfunction tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);\n    const transaction = new web3_js_1.Transaction();\n    const lamports = yield getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n    if (lamports > 0) {\n      transaction.add(web3_js_1.SystemProgram.transfer({\n        fromPubkey: payer.publicKey,\n        toPubkey: mint,\n        lamports: lamports\n      }));\n    }\n    transaction.add((0, spl_token_metadata_1.createUpdateFieldInstruction)({\n      programId,\n      metadata: mint,\n      updateAuthority: updateAuthorityPublicKey,\n      field,\n      value\n    }));\n    return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);\n  });\n}\nexports.tokenMetadataUpdateFieldWithRentTransfer = tokenMetadataUpdateFieldWithRentTransfer;\n/**\n * Remove a field in a token-metadata account.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param key              Key to remove in the additional metadata portion\n * @param idempotent       When true, instruction will not error if the key does not exist\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nfunction tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);\n    const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createRemoveKeyInstruction)({\n      programId,\n      metadata: mint,\n      updateAuthority: updateAuthorityPublicKey,\n      key,\n      idempotent\n    }));\n    return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);\n  });\n}\nexports.tokenMetadataRemoveKey = tokenMetadataRemoveKey;\n/**\n *  Update authority\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param newAuthority     New authority for the token metadata, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nfunction tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);\n    const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateAuthorityInstruction)({\n      programId,\n      metadata: mint,\n      oldAuthority: updateAuthorityPublicKey,\n      newAuthority\n    }));\n    return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);\n  });\n}\nexports.tokenMetadataUpdateAuthority = tokenMetadataUpdateAuthority;\n//# sourceMappingURL=actions.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}