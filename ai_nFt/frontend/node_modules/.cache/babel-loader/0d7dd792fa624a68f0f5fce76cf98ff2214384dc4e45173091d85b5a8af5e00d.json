{"ast":null,"code":"import { blob, greedy, seq, struct, u32, u8 } from '@solana/buffer-layout';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TokenTransferHookAccountNotFound } from '../../errors.js';\nimport { unpackSeeds } from './seeds.js';\n/** Buffer layout for de/serializing a transfer hook extension */\nexport const TransferHookLayout = struct([publicKey('authority'), publicKey('programId')]);\nexport const TRANSFER_HOOK_SIZE = TransferHookLayout.span;\nexport function getTransferHook(mint) {\n  const extensionData = getExtensionData(ExtensionType.TransferHook, mint.tlvData);\n  if (extensionData !== null) {\n    return TransferHookLayout.decode(extensionData);\n  } else {\n    return null;\n  }\n}\n/** Buffer layout for de/serializing a transfer hook account extension */\nexport const TransferHookAccountLayout = struct([bool('transferring')]);\nexport const TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;\nexport function getTransferHookAccount(account) {\n  const extensionData = getExtensionData(ExtensionType.TransferHookAccount, account.tlvData);\n  if (extensionData !== null) {\n    return TransferHookAccountLayout.decode(extensionData);\n  } else {\n    return null;\n  }\n}\nexport function getExtraAccountMetaAddress(mint, programId) {\n  const seeds = [Buffer.from('extra-account-metas'), mint.toBuffer()];\n  return PublicKey.findProgramAddressSync(seeds, programId)[0];\n}\n/** Buffer layout for de/serializing an ExtraAccountMeta */\nexport const ExtraAccountMetaLayout = struct([u8('discriminator'), blob(32, 'addressConfig'), bool('isSigner'), bool('isWritable')]);\n/** Buffer layout for de/serializing a list of ExtraAccountMeta prefixed by a u32 length */\nexport const ExtraAccountMetaListLayout = struct([u32('count'), seq(ExtraAccountMetaLayout, greedy(ExtraAccountMetaLayout.span), 'extraAccounts')]);\n/** Buffer layout for de/serializing an ExtraAccountMetaAccountData */\nexport const ExtraAccountMetaAccountDataLayout = struct([u64('instructionDiscriminator'), u32('length'), ExtraAccountMetaListLayout.replicate('extraAccountsList')]);\n/** Unpack an extra account metas account and parse the data into a list of ExtraAccountMetas */\nexport function getExtraAccountMetas(account) {\n  const extraAccountsList = ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;\n  return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);\n}\n/** Take an ExtraAccountMeta and construct that into an acutal AccountMeta */\nexport async function resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {\n  if (extraMeta.discriminator === 0) {\n    return {\n      pubkey: new PublicKey(extraMeta.addressConfig),\n      isSigner: extraMeta.isSigner,\n      isWritable: extraMeta.isWritable\n    };\n  }\n  let programId = PublicKey.default;\n  if (extraMeta.discriminator === 1) {\n    programId = transferHookProgramId;\n  } else {\n    const accountIndex = extraMeta.discriminator - (1 << 7);\n    if (previousMetas.length <= accountIndex) {\n      throw new TokenTransferHookAccountNotFound();\n    }\n    programId = previousMetas[accountIndex].pubkey;\n  }\n  const seeds = await unpackSeeds(extraMeta.addressConfig, previousMetas, instructionData, connection);\n  const pubkey = PublicKey.findProgramAddressSync(seeds, programId)[0];\n  return {\n    pubkey,\n    isSigner: extraMeta.isSigner,\n    isWritable: extraMeta.isWritable\n  };\n}\n//# sourceMappingURL=state.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}