{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE } from '@solana/errors';\nimport { createEncoder, createDecoder, combineCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n      alphabet: alphabet4,\n      base: alphabet4.length,\n      value: givenValue\n    });\n  }\n}\nvar getBaseXEncoder = alphabet4 => {\n  return createEncoder({\n    getSizeFromValue: value => {\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) return value.length;\n      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n    },\n    write(value, bytes, offset) {\n      assertValidBaseString(alphabet4, value);\n      if (value === \"\") return offset;\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) {\n        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n        return offset + leadingZeroes.length;\n      }\n      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      const tailBytes = [];\n      while (base10Number > 0n) {\n        tailBytes.unshift(Number(base10Number % 256n));\n        base10Number /= 256n;\n      }\n      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getBaseXDecoder = alphabet4 => {\n  return createDecoder({\n    read(rawBytes, offset) {\n      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n      if (bytes.length === 0) return [\"\", 0];\n      let trailIndex = bytes.findIndex(n => n !== 0);\n      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n      const leadingZeroes = alphabet4[0].repeat(trailIndex);\n      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n      return [leadingZeroes + tailChars, rawBytes.length];\n    }\n  });\n};\nvar getBaseXCodec = alphabet4 => combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n  return [leadingZeros, tailChars];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  let sum = 0n;\n  for (const char of value) {\n    sum *= base;\n    sum += BigInt(alphabet4.indexOf(char));\n  }\n  return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  const tailChars = [];\n  while (value > 0n) {\n    tailChars.unshift(alphabet4[Number(value % base)]);\n    value /= base;\n  }\n  return tailChars.join(\"\");\n}\n\n// src/base10.ts\nvar alphabet = \"0123456789\";\nvar getBase10Encoder = () => getBaseXEncoder(alphabet);\nvar getBase10Decoder = () => getBaseXDecoder(alphabet);\nvar getBase10Codec = () => getBaseXCodec(alphabet);\nvar INVALID_STRING_ERROR_BASE_CONFIG = {\n  alphabet: \"0123456789abcdef\",\n  base: 16\n};\nfunction charCodeToBase16(char) {\n  if (char >= 48 /* ZERO */ && char <= 57 /* NINE */) return char - 48 /* ZERO */;\n  if (char >= 65 /* A_UP */ && char <= 70 /* F_UP */) return char - (65 /* A_UP */ - 10);\n  if (char >= 97 /* A_LO */ && char <= 102 /* F_LO */) return char - (97 /* A_LO */ - 10);\n}\nvar getBase16Encoder = () => createEncoder({\n  getSizeFromValue: value => Math.ceil(value.length / 2),\n  write(value, bytes, offset) {\n    const len = value.length;\n    const al = len / 2;\n    if (len === 1) {\n      const c = value.charCodeAt(0);\n      const n = charCodeToBase16(c);\n      if (n === void 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      bytes.set([n], offset);\n      return 1 + offset;\n    }\n    const hexBytes = new Uint8Array(al);\n    for (let i = 0, j = 0; i < al; i++) {\n      const c1 = value.charCodeAt(j++);\n      const c2 = value.charCodeAt(j++);\n      const n1 = charCodeToBase16(c1);\n      const n2 = charCodeToBase16(c2);\n      if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;\n    }\n    bytes.set(hexBytes, offset);\n    return hexBytes.length + offset;\n  }\n});\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nvar getBase16Codec = () => combineCodec(getBase16Encoder(), getBase16Decoder());\n\n// src/base58.ts\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = () => getBaseXEncoder(alphabet2);\nvar getBase58Decoder = () => getBaseXDecoder(alphabet2);\nvar getBase58Codec = () => getBaseXCodec(alphabet2);\nvar getBaseXResliceEncoder = (alphabet4, bits) => createEncoder({\n  getSizeFromValue: value => Math.floor(value.length * bits / 8),\n  write(value, bytes, offset) {\n    assertValidBaseString(alphabet4, value);\n    if (value === \"\") return offset;\n    const charIndices = [...value].map(c => alphabet4.indexOf(c));\n    const reslicedBytes = reslice(charIndices, bits, 8, false);\n    bytes.set(reslicedBytes, offset);\n    return reslicedBytes.length + offset;\n  }\n});\nvar getBaseXResliceDecoder = (alphabet4, bits) => createDecoder({\n  read(rawBytes, offset = 0) {\n    const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n    if (bytes.length === 0) return [\"\", rawBytes.length];\n    const charIndices = reslice([...bytes], 8, bits, true);\n    return [charIndices.map(i => alphabet4[i]).join(\"\"), rawBytes.length];\n  }\n});\nvar getBaseXResliceCodec = (alphabet4, bits) => combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));\nfunction reslice(input, inputBits, outputBits, useRemainder) {\n  const output = [];\n  let accumulator = 0;\n  let bitsInAccumulator = 0;\n  const mask = (1 << outputBits) - 1;\n  for (const value of input) {\n    accumulator = accumulator << inputBits | value;\n    bitsInAccumulator += inputBits;\n    while (bitsInAccumulator >= outputBits) {\n      bitsInAccumulator -= outputBits;\n      output.push(accumulator >> bitsInAccumulator & mask);\n    }\n  }\n  if (useRemainder && bitsInAccumulator > 0) {\n    output.push(accumulator << outputBits - bitsInAccumulator & mask);\n  }\n  return output;\n}\n\n// src/base64.ts\nvar alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar getBase64Encoder = () => {\n  {\n    return createEncoder({\n      getSizeFromValue: value => {\n        try {\n          return atob(value).length;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      },\n      write(value, bytes, offset) {\n        try {\n          const bytesToAdd = atob(value).split(\"\").map(c => c.charCodeAt(0));\n          bytes.set(bytesToAdd, offset);\n          return bytesToAdd.length + offset;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      }\n    });\n  }\n};\nvar getBase64Decoder = () => {\n  {\n    return createDecoder({\n      read(bytes, offset = 0) {\n        const slice = bytes.slice(offset);\n        const value = btoa(String.fromCharCode(...slice));\n        return [value, bytes.length];\n      }\n    });\n  }\n};\nvar getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder());\n\n// src/null-characters.ts\nvar removeNullCharacters = value =>\n// eslint-disable-next-line no-control-regex\nvalue.replace(/\\u0000/g, \"\");\nvar padNullCharacters = (value, chars) => value.padEnd(chars, \"\\0\");\n\n// ../text-encoding-impl/dist/index.browser.mjs\nvar e = globalThis.TextDecoder;\nvar o = globalThis.TextEncoder;\n\n// src/utf8.ts\nvar getUtf8Encoder = () => {\n  let textEncoder;\n  return createEncoder({\n    getSizeFromValue: value => (textEncoder ||= new o()).encode(value).length,\n    write: (value, bytes, offset) => {\n      const bytesToAdd = (textEncoder ||= new o()).encode(value);\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getUtf8Decoder = () => {\n  let textDecoder;\n  return createDecoder({\n    read(bytes, offset) {\n      const value = (textDecoder ||= new e()).decode(bytes.slice(offset));\n      return [removeNullCharacters(value), bytes.length];\n    }\n  });\n};\nvar getUtf8Codec = () => combineCodec(getUtf8Encoder(), getUtf8Decoder());\nexport { assertValidBaseString, getBase10Codec, getBase10Decoder, getBase10Encoder, getBase16Codec, getBase16Decoder, getBase16Encoder, getBase58Codec, getBase58Decoder, getBase58Encoder, getBase64Codec, getBase64Decoder, getBase64Encoder, getBaseXCodec, getBaseXDecoder, getBaseXEncoder, getBaseXResliceCodec, getBaseXResliceDecoder, getBaseXResliceEncoder, getUtf8Codec, getUtf8Decoder, getUtf8Encoder, padNullCharacters, removeNullCharacters };\n\n//# sourceMappingURL=index.browser.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}