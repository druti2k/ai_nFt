{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveExtraAccountMeta = exports.getExtraAccountMetas = exports.ExtraAccountMetaAccountDataLayout = exports.ExtraAccountMetaListLayout = exports.ExtraAccountMetaLayout = exports.getExtraAccountMetaAddress = exports.getTransferHookAccount = exports.TRANSFER_HOOK_ACCOUNT_SIZE = exports.TransferHookAccountLayout = exports.getTransferHook = exports.TRANSFER_HOOK_SIZE = exports.TransferHookLayout = void 0;\nconst buffer_layout_1 = require(\"@solana/buffer-layout\");\nconst extensionType_js_1 = require(\"../extensionType.js\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\nconst errors_js_1 = require(\"../../errors.js\");\nconst seeds_js_1 = require(\"./seeds.js\");\n/** Buffer layout for de/serializing a transfer hook extension */\nexports.TransferHookLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)('authority'), (0, buffer_layout_utils_1.publicKey)('programId')]);\nexports.TRANSFER_HOOK_SIZE = exports.TransferHookLayout.span;\nfunction getTransferHook(mint) {\n  const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHook, mint.tlvData);\n  if (extensionData !== null) {\n    return exports.TransferHookLayout.decode(extensionData);\n  } else {\n    return null;\n  }\n}\nexports.getTransferHook = getTransferHook;\n/** Buffer layout for de/serializing a transfer hook account extension */\nexports.TransferHookAccountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)('transferring')]);\nexports.TRANSFER_HOOK_ACCOUNT_SIZE = exports.TransferHookAccountLayout.span;\nfunction getTransferHookAccount(account) {\n  const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHookAccount, account.tlvData);\n  if (extensionData !== null) {\n    return exports.TransferHookAccountLayout.decode(extensionData);\n  } else {\n    return null;\n  }\n}\nexports.getTransferHookAccount = getTransferHookAccount;\nfunction getExtraAccountMetaAddress(mint, programId) {\n  const seeds = [Buffer.from('extra-account-metas'), mint.toBuffer()];\n  return web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];\n}\nexports.getExtraAccountMetaAddress = getExtraAccountMetaAddress;\n/** Buffer layout for de/serializing an ExtraAccountMeta */\nexports.ExtraAccountMetaLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('discriminator'), (0, buffer_layout_1.blob)(32, 'addressConfig'), (0, buffer_layout_utils_1.bool)('isSigner'), (0, buffer_layout_utils_1.bool)('isWritable')]);\n/** Buffer layout for de/serializing a list of ExtraAccountMeta prefixed by a u32 length */\nexports.ExtraAccountMetaListLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u32)('count'), (0, buffer_layout_1.seq)(exports.ExtraAccountMetaLayout, (0, buffer_layout_1.greedy)(exports.ExtraAccountMetaLayout.span), 'extraAccounts')]);\n/** Buffer layout for de/serializing an ExtraAccountMetaAccountData */\nexports.ExtraAccountMetaAccountDataLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)('instructionDiscriminator'), (0, buffer_layout_1.u32)('length'), exports.ExtraAccountMetaListLayout.replicate('extraAccountsList')]);\n/** Unpack an extra account metas account and parse the data into a list of ExtraAccountMetas */\nfunction getExtraAccountMetas(account) {\n  const extraAccountsList = exports.ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;\n  return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);\n}\nexports.getExtraAccountMetas = getExtraAccountMetas;\n/** Take an ExtraAccountMeta and construct that into an acutal AccountMeta */\nfunction resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (extraMeta.discriminator === 0) {\n      return {\n        pubkey: new web3_js_1.PublicKey(extraMeta.addressConfig),\n        isSigner: extraMeta.isSigner,\n        isWritable: extraMeta.isWritable\n      };\n    }\n    let programId = web3_js_1.PublicKey.default;\n    if (extraMeta.discriminator === 1) {\n      programId = transferHookProgramId;\n    } else {\n      const accountIndex = extraMeta.discriminator - (1 << 7);\n      if (previousMetas.length <= accountIndex) {\n        throw new errors_js_1.TokenTransferHookAccountNotFound();\n      }\n      programId = previousMetas[accountIndex].pubkey;\n    }\n    const seeds = yield (0, seeds_js_1.unpackSeeds)(extraMeta.addressConfig, previousMetas, instructionData, connection);\n    const pubkey = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];\n    return {\n      pubkey,\n      isSigner: extraMeta.isSigner,\n      isWritable: extraMeta.isWritable\n    };\n  });\n}\nexports.resolveExtraAccountMeta = resolveExtraAccountMeta;\n//# sourceMappingURL=state.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}