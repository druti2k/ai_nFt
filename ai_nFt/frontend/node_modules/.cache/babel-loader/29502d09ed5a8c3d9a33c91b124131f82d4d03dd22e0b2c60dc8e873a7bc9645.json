{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTransferCheckedWithFeeAndTransferHookInstruction = exports.createTransferCheckedWithTransferHookInstruction = exports.addExtraAccountsToInstruction = exports.createUpdateTransferHookInstruction = exports.updateTransferHookInstructionData = exports.createInitializeTransferHookInstruction = exports.initializeTransferHookInstructionData = exports.TransferHookInstruction = void 0;\nconst buffer_layout_1 = require(\"@solana/buffer-layout\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst constants_js_1 = require(\"../../constants.js\");\nconst errors_js_1 = require(\"../../errors.js\");\nconst internal_js_1 = require(\"../../instructions/internal.js\");\nconst types_js_1 = require(\"../../instructions/types.js\");\nconst buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\nconst transferChecked_js_1 = require(\"../../instructions/transferChecked.js\");\nconst instructions_js_1 = require(\"../transferFee/instructions.js\");\nconst mint_js_1 = require(\"../../state/mint.js\");\nconst state_js_1 = require(\"./state.js\");\nvar TransferHookInstruction;\n(function (TransferHookInstruction) {\n  TransferHookInstruction[TransferHookInstruction[\"Initialize\"] = 0] = \"Initialize\";\n  TransferHookInstruction[TransferHookInstruction[\"Update\"] = 1] = \"Update\";\n})(TransferHookInstruction || (exports.TransferHookInstruction = TransferHookInstruction = {}));\n/** The struct that represents the instruction data as it is read by the program */\nexports.initializeTransferHookInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('instruction'), (0, buffer_layout_1.u8)('transferHookInstruction'), (0, buffer_layout_utils_1.publicKey)('authority'), (0, buffer_layout_utils_1.publicKey)('transferHookProgramId')]);\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {\n  if (!(0, constants_js_1.programSupportsExtensions)(programId)) {\n    throw new errors_js_1.TokenUnsupportedInstructionError();\n  }\n  const keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  const data = Buffer.alloc(exports.initializeTransferHookInstructionData.span);\n  exports.initializeTransferHookInstructionData.encode({\n    instruction: types_js_1.TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Initialize,\n    authority,\n    transferHookProgramId\n  }, data);\n  return new web3_js_1.TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\nexports.createInitializeTransferHookInstruction = createInitializeTransferHookInstruction;\n/** The struct that represents the instruction data as it is read by the program */\nexports.updateTransferHookInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('instruction'), (0, buffer_layout_1.u8)('transferHookInstruction'), (0, buffer_layout_utils_1.publicKey)('transferHookProgramId')]);\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {\n  if (!(0, constants_js_1.programSupportsExtensions)(programId)) {\n    throw new errors_js_1.TokenUnsupportedInstructionError();\n  }\n  const keys = (0, internal_js_1.addSigners)([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }], authority, multiSigners);\n  const data = Buffer.alloc(exports.updateTransferHookInstructionData.span);\n  exports.updateTransferHookInstructionData.encode({\n    instruction: types_js_1.TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Update,\n    transferHookProgramId\n  }, data);\n  return new web3_js_1.TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\nexports.createUpdateTransferHookInstruction = createUpdateTransferHookInstruction;\nfunction deEscalateAccountMeta(accountMeta, accountMetas) {\n  const maybeHighestPrivileges = accountMetas.filter(x => x.pubkey === accountMeta.pubkey).reduce((acc, x) => {\n    if (!acc) return {\n      isSigner: x.isSigner,\n      isWritable: x.isWritable\n    };\n    return {\n      isSigner: acc.isSigner || x.isSigner,\n      isWritable: acc.isWritable || x.isWritable\n    };\n  }, undefined);\n  if (maybeHighestPrivileges) {\n    const {\n      isSigner,\n      isWritable\n    } = maybeHighestPrivileges;\n    if (!isSigner && isSigner !== accountMeta.isSigner) {\n      accountMeta.isSigner = false;\n    }\n    if (!isWritable && isWritable !== accountMeta.isWritable) {\n      accountMeta.isWritable = false;\n    }\n  }\n  return accountMeta;\n}\n/**\n * Add extra accounts needed for transfer hook to an instruction\n *\n * @param connection      Connection to use\n * @param instruction     The transferChecked instruction to add accounts to\n * @param commitment      Commitment to use\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction addExtraAccountsToInstruction(connection, instruction, mint, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!(0, constants_js_1.programSupportsExtensions)(programId)) {\n      throw new errors_js_1.TokenUnsupportedInstructionError();\n    }\n    const mintInfo = yield (0, mint_js_1.getMint)(connection, mint, commitment, programId);\n    const transferHook = (0, state_js_1.getTransferHook)(mintInfo);\n    if (transferHook == null) {\n      return instruction;\n    }\n    const extraAccountsAccount = (0, state_js_1.getExtraAccountMetaAddress)(mint, transferHook.programId);\n    const extraAccountsInfo = yield connection.getAccountInfo(extraAccountsAccount, commitment);\n    if (extraAccountsInfo == null) {\n      return instruction;\n    }\n    const extraAccountMetas = (0, state_js_1.getExtraAccountMetas)(extraAccountsInfo);\n    const accountMetas = instruction.keys;\n    for (const extraAccountMeta of extraAccountMetas) {\n      const accountMetaUnchecked = yield (0, state_js_1.resolveExtraAccountMeta)(connection, extraAccountMeta, accountMetas, instruction.data, transferHook.programId);\n      const accountMeta = deEscalateAccountMeta(accountMetaUnchecked, accountMetas);\n      accountMetas.push(accountMeta);\n    }\n    accountMetas.push({\n      pubkey: transferHook.programId,\n      isSigner: false,\n      isWritable: false\n    });\n    accountMetas.push({\n      pubkey: extraAccountsAccount,\n      isSigner: false,\n      isWritable: false\n    });\n    return new web3_js_1.TransactionInstruction({\n      keys: accountMetas,\n      programId,\n      data: instruction.data\n    });\n  });\n}\nexports.addExtraAccountsToInstruction = addExtraAccountsToInstruction;\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const rawInstruction = (0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, authority, amount, decimals, multiSigners, programId);\n    const hydratedInstruction = yield addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);\n    return hydratedInstruction;\n  });\n}\nexports.createTransferCheckedWithTransferHookInstruction = createTransferCheckedWithTransferHookInstruction;\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const rawInstruction = (0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, authority, amount, decimals, fee, multiSigners, programId);\n    const hydratedInstruction = yield addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);\n    return hydratedInstruction;\n  });\n}\nexports.createTransferCheckedWithFeeAndTransferHookInstruction = createTransferCheckedWithFeeAndTransferHookInstruction;\n//# sourceMappingURL=instructions.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}