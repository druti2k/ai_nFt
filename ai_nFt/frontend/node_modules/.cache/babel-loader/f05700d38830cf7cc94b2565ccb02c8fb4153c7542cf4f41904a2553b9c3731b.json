{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unpackSeeds = void 0;\nconst errors_js_1 = require(\"../../errors.js\");\nconst DISCRIMINATOR_SPAN = 1;\nconst LITERAL_LENGTH_SPAN = 1;\nconst INSTRUCTION_ARG_OFFSET_SPAN = 1;\nconst INSTRUCTION_ARG_LENGTH_SPAN = 1;\nconst ACCOUNT_KEY_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_OFFSET_SPAN = 1;\nconst ACCOUNT_DATA_LENGTH_SPAN = 1;\nfunction unpackSeedLiteral(seeds) {\n  if (seeds.length < 1) {\n    throw new errors_js_1.TokenTransferHookInvalidSeed();\n  }\n  const [length, ...rest] = seeds;\n  if (rest.length < length) {\n    throw new errors_js_1.TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: Buffer.from(rest.slice(0, length)),\n    packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length\n  };\n}\nfunction unpackSeedInstructionArg(seeds, instructionData) {\n  if (seeds.length < 2) {\n    throw new errors_js_1.TokenTransferHookInvalidSeed();\n  }\n  const [index, length] = seeds;\n  if (instructionData.length < length + index) {\n    throw new errors_js_1.TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: instructionData.subarray(index, index + length),\n    packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN\n  };\n}\nfunction unpackSeedAccountKey(seeds, previousMetas) {\n  if (seeds.length < 1) {\n    throw new errors_js_1.TokenTransferHookInvalidSeed();\n  }\n  const [index] = seeds;\n  if (previousMetas.length <= index) {\n    throw new errors_js_1.TokenTransferHookInvalidSeed();\n  }\n  return {\n    data: previousMetas[index].pubkey.toBuffer(),\n    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN\n  };\n}\nfunction unpackSeedAccountData(seeds, previousMetas, connection) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (seeds.length < 3) {\n      throw new errors_js_1.TokenTransferHookInvalidSeed();\n    }\n    const [accountIndex, dataIndex, length] = seeds;\n    if (previousMetas.length <= accountIndex) {\n      throw new errors_js_1.TokenTransferHookInvalidSeed();\n    }\n    const accountInfo = yield connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n    if (accountInfo == null) {\n      throw new errors_js_1.TokenTransferHookAccountDataNotFound();\n    }\n    if (accountInfo.data.length < dataIndex + length) {\n      throw new errors_js_1.TokenTransferHookInvalidSeed();\n    }\n    return {\n      data: accountInfo.data.subarray(dataIndex, dataIndex + length),\n      packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN\n    };\n  });\n}\nfunction unpackFirstSeed(seeds, previousMetas, instructionData, connection) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [discriminator, ...rest] = seeds;\n    const remaining = new Uint8Array(rest);\n    switch (discriminator) {\n      case 0:\n        return null;\n      case 1:\n        return unpackSeedLiteral(remaining);\n      case 2:\n        return unpackSeedInstructionArg(remaining, instructionData);\n      case 3:\n        return unpackSeedAccountKey(remaining, previousMetas);\n      case 4:\n        return unpackSeedAccountData(remaining, previousMetas, connection);\n      default:\n        throw new errors_js_1.TokenTransferHookInvalidSeed();\n    }\n  });\n}\nfunction unpackSeeds(seeds, previousMetas, instructionData, connection) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const unpackedSeeds = [];\n    let i = 0;\n    while (i < 32) {\n      const seed = yield unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);\n      if (seed == null) {\n        break;\n      }\n      unpackedSeeds.push(seed.data);\n      i += seed.packedLength;\n    }\n    return unpackedSeeds;\n  });\n}\nexports.unpackSeeds = unpackSeeds;\n//# sourceMappingURL=seeds.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}