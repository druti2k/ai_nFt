{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAssociatedTokenAddressSync = exports.getAssociatedTokenAddress = exports.getMinimumBalanceForRentExemptMintWithExtensions = exports.getMinimumBalanceForRentExemptMint = exports.unpackMint = exports.getMint = exports.MINT_SIZE = exports.MintLayout = void 0;\nconst buffer_layout_1 = require(\"@solana/buffer-layout\");\nconst buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst constants_js_1 = require(\"../constants.js\");\nconst errors_js_1 = require(\"../errors.js\");\nconst accountType_js_1 = require(\"../extensions/accountType.js\");\nconst extensionType_js_1 = require(\"../extensions/extensionType.js\");\nconst account_js_1 = require(\"./account.js\");\nconst multisig_js_1 = require(\"./multisig.js\");\n/** Buffer layout for de/serializing a mint */\nexports.MintLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u32)('mintAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('mintAuthority'), (0, buffer_layout_utils_1.u64)('supply'), (0, buffer_layout_1.u8)('decimals'), (0, buffer_layout_utils_1.bool)('isInitialized'), (0, buffer_layout_1.u32)('freezeAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('freezeAuthority')]);\n/** Byte length of a mint */\nexports.MINT_SIZE = exports.MintLayout.span;\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nfunction getMint(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const info = yield connection.getAccountInfo(address, commitment);\n    return unpackMint(address, info, programId);\n  });\n}\nexports.getMint = getMint;\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\nfunction unpackMint(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {\n  if (!info) throw new errors_js_1.TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new errors_js_1.TokenInvalidAccountOwnerError();\n  if (info.data.length < exports.MINT_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n  const rawMint = exports.MintLayout.decode(info.data.slice(0, exports.MINT_SIZE));\n  let tlvData = Buffer.alloc(0);\n  if (info.data.length > exports.MINT_SIZE) {\n    if (info.data.length <= account_js_1.ACCOUNT_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n    if (info.data.length === multisig_js_1.MULTISIG_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n    if (info.data[account_js_1.ACCOUNT_SIZE] != accountType_js_1.AccountType.Mint) throw new errors_js_1.TokenInvalidMintError();\n    tlvData = info.data.slice(account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);\n  }\n  return {\n    address,\n    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n    supply: rawMint.supply,\n    decimals: rawMint.decimals,\n    isInitialized: rawMint.isInitialized,\n    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n    tlvData\n  };\n}\nexports.unpackMint = unpackMint;\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nfunction getMinimumBalanceForRentExemptMint(connection, commitment) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return yield getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n  });\n}\nexports.getMinimumBalanceForRentExemptMint = getMinimumBalanceForRentExemptMint;\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nfunction getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const mintLen = (0, extensionType_js_1.getMintLen)(extensions);\n    return yield connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n  });\n}\nexports.getMinimumBalanceForRentExemptMintWithExtensions = getMinimumBalanceForRentExemptMintWithExtensions;\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\nfunction getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer())) throw new errors_js_1.TokenOwnerOffCurveError();\n    const [address] = yield web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n    return address;\n  });\n}\nexports.getAssociatedTokenAddress = getAssociatedTokenAddress;\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nfunction getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {\n  if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer())) throw new errors_js_1.TokenOwnerOffCurveError();\n  const [address] = web3_js_1.PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n  return address;\n}\nexports.getAssociatedTokenAddressSync = getAssociatedTokenAddressSync;\n//# sourceMappingURL=mint.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}